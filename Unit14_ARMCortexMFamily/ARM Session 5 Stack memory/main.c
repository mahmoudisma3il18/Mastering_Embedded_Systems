/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x8.h"
#include "stm32f103x8_EXTI_driver.h"
#include "cmsis_armclang.h"



/* =============== Macros to Switch access level ==================== */
	
	/* Read Data from CONTROL register and or with 0x1 and
	write data to register */

#define ACCESS_LEVEL_UNPRIVILEGE() \
        __asm("MRS R0,CONTROL");   \
				__asm("ORR R0,R0,#0x01");  \
				__asm("MSR CONTROL,R0");   
				
#define ACCESS_LEVEL_PRIVILEGE()	 \
        __asm("MRS R0,CONTROL");             \
        __asm("LSR R0,R0,#0x01");            \
				__asm("LSL R0,R0,#0x01");            \
				__asm("MSR CONTROL,R0");
				
#define OS_SWITCH_SP_TO_PSP()      \
        __asm("MRS R0,CONTROL");	 \
				__asm("ORR R0,R0,#0x02");  \
				__asm("MSR CONTROL,R0");
				
				
#define OS_SWITCH_SP_TO_MSP()      \
        __asm("MRS R0,CONTROL");   \
        __asm("AND R0,R0,#0x05");  \
        __asm("MSR CONTROL,R0");				
				
#define OS_SET_PSP(address)        \
        __asm("MSR PSP,%0"         \
				:: "r" (address));
				

#define OS_GENERATE_EXCEPTION()    \
        __asm("SVC #0x03")				
				
				
							
					
/* ====================  Tasks Defines =========================== */				
				
 #define TaskA_Stack_Size       100    /* 100 Byte */
 #define TaskB_Stack_Size       100    /* 100 Byte */
 #define Main_Stack_Size        512    /* 512 Byte */
 #define Stack_Margin           8      /* Margin after every stack */
 				
 
 /* ================== Main Stack Pointer ========================= */	
 
volatile unsigned int _S_MSP ;
volatile unsigned int _E_MSP ;

 /* ================== Process Stack Pointer =======================*/
 
 /* Task A */
volatile unsigned int _S_PSP_TaskA;
volatile unsigned int _E_PSP_TaskA;
 
 /* Task B */
volatile unsigned int _S_PSP_TaskB;
volatile unsigned int _E_PSP_TaskB;
 
 /* Flags */
 uint8_t IRQ_Flag ;
 uint8_t TaskA_Flag;
 uint8_t TaskB_Flag;
 
 
 /* ====================== OS Function ==========================*/
 
 int TaskA(int a,int b) {
 
	return a+b;
	
 }
 
 int TaskB(int a, int b, int c) {
 
	return a+b+c;
 
 }
 
 void Main_OS(void) {
 
 /* Set End of of Main Stack */
 _E_MSP = _S_MSP - Main_Stack_Size;                  
 
 /* Set start of PSP for TaskA */
 _S_PSP_TaskA = _E_MSP - Stack_Margin;  
 
 /* Set End of of TaskA Stack */ 
 _E_PSP_TaskA = _S_PSP_TaskA - TaskA_Stack_Size;  
 
 /* Set start of PSP for TaskB */
 _S_PSP_TaskB = _E_PSP_TaskA - Stack_Margin;  
 
 /* Set End of of TaskB Stack */ 
 _E_PSP_TaskB = _S_PSP_TaskB - TaskB_Stack_Size;    
 
 while(1)
 {
   __asm("NOP");
	 
	 if(TaskA_Flag == 1)
	 {
	 
	   /* Set PSP to start address of taskA */
	   OS_SET_PSP(_S_PSP_TaskA);
		 
		 /* Set SP to shadow to PSP */
		 OS_SWITCH_SP_TO_PSP();
		 
		 /* Switch to unprivilege */
		 ACCESS_LEVEL_UNPRIVILEGE();
		 
		 /* Call Task */
		 TaskA_Flag = TaskA(1,1);
		 
		 /* Switch to Privilege */
		 OS_GENERATE_EXCEPTION();
		 
		 /* SP -> MSP */
		 OS_SWITCH_SP_TO_MSP();
		 
	 }
	 else if(TaskB_Flag == 1)
	 {
	   /* Set PSP to start address of taskA */
	   OS_SET_PSP(_S_PSP_TaskB);
		 
		 /* Set SP to shadow to PSP */
		 OS_SWITCH_SP_TO_PSP();
		 
		 /* Switch to unprivilege */
		 ACCESS_LEVEL_UNPRIVILEGE();
		 
		 /* Call Task */
		 TaskB_Flag = TaskB(1,1,1);
		 
		 /* Switch to Privilege */
		 OS_GENERATE_EXCEPTION();
		 
		 /* SP -> MSP */
		 OS_SWITCH_SP_TO_MSP();
		 
	 }
 }
 
}
 
 
void EXTI9_CALLBACK(void)
{
	if(IRQ_Flag == 0)
	{
		TaskA_Flag = 1;
		IRQ_Flag = 1;
	}
	else if(IRQ_Flag == 1)
	{
		TaskB_Flag = 1;
		IRQ_Flag = 0;
	}
}

void SVC_Handler(void)
{
	ACCESS_LEVEL_PRIVILEGE();
}



int main(void)
{
  
	/* Read Value of SP and store it in _S_MSP */
	__asm("MRS %0 , MSP"
	      :"=r" (_S_MSP));
	
	
	
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	//Set EXTI Configuration
	EXTI_PinConfig_t EXTIConfig;
	EXTIConfig.EXTI_PIN = EXTI9PB9;
	EXTIConfig.Trigger_Case = EXTI_Trigger_RISING;
	EXTIConfig.P_IRQ_CallBack = EXTI9_CALLBACK;
	EXTIConfig.IRQ_EN = EXTI_IRQ_Enable;
	MCAL_EXTI_GPIO_Init(&EXTIConfig);


  Main_OS();
	
	IRQ_Flag = 1;
	

  
	__asm("nop \t\n nop \t\n nop");	
  Main_OS();	
	
	ACCESS_LEVEL_UNPRIVILEGE();
	
	
	while (1)
	{
	  if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else { /* Misra */ }
	}


}
